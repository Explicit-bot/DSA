/********************************************************************
 üß† std::set ‚Äî COMPLETE GUIDE (C++ STL)
 UNIQUE ‚Ä¢ SORTED ‚Ä¢ TREE-BASED
*********************************************************************

====================================================================
1Ô∏è‚É£ WHAT IS std::set?
====================================================================
std::set is an ordered associative container that stores
UNIQUE elements in SORTED order.

‚Ä¢ Stores ONLY keys (no values)
‚Ä¢ All elements are UNIQUE
‚Ä¢ Automatically SORTED
‚Ä¢ Implemented using RED-BLACK TREE
‚Ä¢ No random access

------------------------------------------------------------
Header:
------------------------------------------------------------
#include <set>

------------------------------------------------------------
Basic Syntax:
------------------------------------------------------------
set<DataType> st;

Example:
------------------------------------------------------------
set<int> st;
set<string> s;

====================================================================
2Ô∏è‚É£ INTERNAL IMPLEMENTATION
====================================================================
‚Ä¢ Data Structure: Red-Black Tree
‚Ä¢ Self-balancing BST
‚Ä¢ Height: O(log n)

------------------------------------------------------------
Implication:
------------------------------------------------------------
All major operations are O(log n)

====================================================================
3Ô∏è‚É£ KEY RULE (VERY IMPORTANT)
====================================================================
‚Ä¢ Elements must be COMPARABLE (< operator)
‚Ä¢ Duplicates are NOT allowed

------------------------------------------------------------
If duplicate is inserted:
------------------------------------------------------------
Insertion is IGNORED

====================================================================
4Ô∏è‚É£ POSSIBLE DATA TYPES
====================================================================

------------------------------------------------------------
Allowed types:
------------------------------------------------------------
int
long long
char
string
pair<int,int>
vector<int>        // allowed but slow
custom struct      // if < is defined

------------------------------------------------------------
Examples:
------------------------------------------------------------
set<int>
set<string>
set<pair<int,int>>
set<vector<int>>

------------------------------------------------------------
Custom struct example:
------------------------------------------------------------
struct Node{
    int x, y;
    bool operator<(const Node& other) const {
        if(x != other.x) return x < other.x;
        return y < other.y;
    }
};

set<Node> st;

====================================================================
5Ô∏è‚É£ INSERTION
====================================================================

------------------------------------------------------------
insert()
------------------------------------------------------------
st.insert(10);
st.insert(5);
st.insert(10);   // ignored (duplicate)

------------------------------------------------------------
emplace()
------------------------------------------------------------
st.emplace(20);

------------------------------------------------------------
Time Complexity:
------------------------------------------------------------
O(log n)

====================================================================
6Ô∏è‚É£ ACCESSING ELEMENTS
====================================================================

------------------------------------------------------------
‚ùå No index access
------------------------------------------------------------
st[0];   // INVALID

------------------------------------------------------------
Access using iterator:
------------------------------------------------------------
auto it = st.begin();
cout << *it;

====================================================================
7Ô∏è‚É£ find()
====================================================================

------------------------------------------------------------
Syntax:
------------------------------------------------------------
auto it = st.find(x);

------------------------------------------------------------
Returns:
------------------------------------------------------------
‚Ä¢ Iterator if found
‚Ä¢ st.end() if not found

------------------------------------------------------------
Time:
------------------------------------------------------------
O(log n)

====================================================================
8Ô∏è‚É£ count()
====================================================================

------------------------------------------------------------
Syntax:
------------------------------------------------------------
st.count(x);

------------------------------------------------------------
Returns:
------------------------------------------------------------
1 ‚Üí element exists
0 ‚Üí does not exist

------------------------------------------------------------
Time:
------------------------------------------------------------
O(log n)

====================================================================
9Ô∏è‚É£ ERASE (VERY IMPORTANT)
====================================================================

------------------------------------------------------------
Erase by value:
------------------------------------------------------------
st.erase(x);

------------------------------------------------------------
Erase by iterator:
------------------------------------------------------------
auto it = st.find(x);
st.erase(it);

------------------------------------------------------------
Erase range:
------------------------------------------------------------
st.erase(st.begin(), st.end());

------------------------------------------------------------
Time Complexity:
------------------------------------------------------------
erase(value)     ‚Üí O(log n)
erase(iterator) ‚Üí O(1)
erase(range)    ‚Üí O(n)

------------------------------------------------------------
Safe erase while iterating:
------------------------------------------------------------
for(auto it = st.begin(); it != st.end(); ){
    if(*it % 2 == 0)
        it = st.erase(it);
    else
        ++it;
}

====================================================================
üîü TRAVERSAL
====================================================================

------------------------------------------------------------
Normal order:
------------------------------------------------------------
for(auto x : st){
    cout << x << " ";
}

------------------------------------------------------------
Using iterator:
------------------------------------------------------------
for(auto it = st.begin(); it != st.end(); ++it){
    cout << *it << " ";
}

------------------------------------------------------------
Reverse traversal:
------------------------------------------------------------
for(auto it = st.rbegin(); it != st.rend(); ++it){
    cout << *it << " ";
}

====================================================================
1Ô∏è‚É£1Ô∏è‚É£ ITERATORS
====================================================================

‚Ä¢ set iterators are BIDIRECTIONAL

------------------------------------------------------------
Valid:
------------------------------------------------------------
++it
--it

------------------------------------------------------------
Invalid:
------------------------------------------------------------
it + 1   // ‚ùå

====================================================================
1Ô∏è‚É£2Ô∏è‚É£ SIZE, EMPTY, CLEAR
====================================================================

st.size();     // O(1)
st.empty();   // O(1)
st.clear();   // O(n)

====================================================================
1Ô∏è‚É£3Ô∏è‚É£ LOWER_BOUND & UPPER_BOUND (üî• IMPORTANT)
====================================================================

------------------------------------------------------------
lower_bound(x):
------------------------------------------------------------
Returns iterator to FIRST element >= x

------------------------------------------------------------
upper_bound(x):
------------------------------------------------------------
Returns iterator to FIRST element > x

------------------------------------------------------------
Example:
------------------------------------------------------------
set<int> st = {1, 3, 5, 7};

st.lower_bound(4);  // points to 5
st.upper_bound(5);  // points to 7

------------------------------------------------------------
Time:
------------------------------------------------------------
O(log n)

====================================================================
1Ô∏è‚É£4Ô∏è‚É£ STRING AS ELEMENT (SPECIAL CASE)
====================================================================

Let:
------------------------------------------------------------
n = number of elements
L = string length

------------------------------------------------------------
Complexity:
------------------------------------------------------------
insert / find / erase:
O(log n √ó L)

Reason:
------------------------------------------------------------
String comparison is O(L)

====================================================================
1Ô∏è‚É£5Ô∏è‚É£ set vs unordered_set
====================================================================

set:
------------------------------------------------------------
‚Ä¢ Ordered
‚Ä¢ Red-Black Tree
‚Ä¢ O(log n)
‚Ä¢ lower_bound supported

unordered_set:
------------------------------------------------------------
‚Ä¢ Unordered
‚Ä¢ Hash table
‚Ä¢ O(1) average
‚Ä¢ No ordering

====================================================================
1Ô∏è‚É£6Ô∏è‚É£ WHEN TO USE set
====================================================================

‚úî Need unique elements
‚úî Need sorted order
‚úî Need lower_bound / upper_bound
‚úî Deterministic performance

====================================================================
1Ô∏è‚É£7Ô∏è‚É£ COMMON MISTAKES
====================================================================

‚ùå Expecting index access
‚ùå Using it+1
‚ùå Expecting duplicates to be stored
‚ùå Using set<string> for large data

====================================================================
1Ô∏è‚É£8Ô∏è‚É£ CP TIPS
====================================================================

‚Ä¢ Use set when ordering matters
‚Ä¢ For frequency ‚Üí use map
‚Ä¢ For fast presence check ‚Üí unordered_set
‚Ä¢ Prefer set<pair<int,int>> in greedy problems

====================================================================
1Ô∏è‚É£9Ô∏è‚É£ INTERVIEW ONE-LINER
====================================================================

std::set is an ordered associative container implemented
using a Red-Black Tree that stores unique elements and
supports logarithmic insert, delete, and search.

********************************************************************/
