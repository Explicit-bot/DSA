/*
====================================================================
1Ô∏è‚É£ WHAT IS std::unordered_map?
====================================================================
std::unordered_map is an associative container that stores
(KEY, VALUE) pairs using a HASH TABLE.

‚Ä¢ Keys are UNIQUE
‚Ä¢ NO ordering of keys
‚Ä¢ Very FAST average operations
‚Ä¢ Uses HASHING internally

------------------------------------------------------------
Header:
------------------------------------------------------------
#include <unordered_map>

------------------------------------------------------------
Basic Syntax:
------------------------------------------------------------
unordered_map<KeyType, ValueType> ump;

Example:
------------------------------------------------------------
unordered_map<int, int> ump;
unordered_map<string, int> freq;

====================================================================
2Ô∏è‚É£ INTERNAL IMPLEMENTATION
====================================================================
‚Ä¢ Data Structure: Hash Table
‚Ä¢ Uses a HASH FUNCTION to map keys ‚Üí buckets
‚Ä¢ Each bucket stores elements (usually via chaining)

------------------------------------------------------------
Mental Model:
------------------------------------------------------------
key ‚Üí hash(key) ‚Üí bucket ‚Üí value

====================================================================
3Ô∏è‚É£ KEY RULE (VERY IMPORTANT)
====================================================================
KEY:
------------------------------------------------------------
‚Ä¢ Must be HASHABLE
‚Ä¢ Must have == defined

VALUE:
------------------------------------------------------------
‚Ä¢ Can be ANY datatype

------------------------------------------------------------
Built-in hash available for:
------------------------------------------------------------
int
long long
char
string

------------------------------------------------------------
NOT directly hashable:
------------------------------------------------------------
pair<int,int>   ‚ùå
vector<int>     ‚ùå
custom struct   ‚ùå

(unless you define a custom hash)

====================================================================
4Ô∏è‚É£ INSERTION
====================================================================

------------------------------------------------------------
Method 1: operator[]
------------------------------------------------------------
ump[1] = 10;

‚Ä¢ Inserts if key not present
‚Ä¢ Updates if key exists

Average Time:
------------------------------------------------------------
O(1)

Worst Case:
------------------------------------------------------------
O(n)

------------------------------------------------------------
Method 2: insert()
------------------------------------------------------------
ump.insert({2, 20});

------------------------------------------------------------
Method 3: emplace()
------------------------------------------------------------
ump.emplace(3, 30);

====================================================================
5Ô∏è‚É£ ACCESSING ELEMENTS
====================================================================

------------------------------------------------------------
Using operator[]
------------------------------------------------------------
cout << ump[1];

‚ö†Ô∏è If key doesn't exist:
‚Ä¢ New key is created
‚Ä¢ Default value assigned

------------------------------------------------------------
Safe access using find():
------------------------------------------------------------
if(ump.find(1) != ump.end()){
    cout << ump[1];
}

====================================================================
6Ô∏è‚É£ find()
====================================================================

------------------------------------------------------------
Syntax:
------------------------------------------------------------
auto it = ump.find(key);

‚Ä¢ Returns iterator if found
‚Ä¢ Returns ump.end() if not found

------------------------------------------------------------
Time Complexity:
------------------------------------------------------------
Average: O(1)
Worst:   O(n)

====================================================================
7Ô∏è‚É£ count()
====================================================================

------------------------------------------------------------
Syntax:
------------------------------------------------------------
ump.count(key);

‚Ä¢ Returns 1 if exists
‚Ä¢ Returns 0 otherwise

------------------------------------------------------------
Time:
------------------------------------------------------------
Average: O(1)
Worst:   O(n)

====================================================================
8Ô∏è‚É£ ERASE (VERY IMPORTANT)
====================================================================

------------------------------------------------------------
Erase by key:
------------------------------------------------------------
ump.erase(key);

------------------------------------------------------------
Erase by iterator:
------------------------------------------------------------
auto it = ump.find(key);
ump.erase(it);

------------------------------------------------------------
Erase range:
------------------------------------------------------------
ump.erase(ump.begin(), ump.end());

------------------------------------------------------------
Time Complexity:
------------------------------------------------------------
Average: O(1)
Worst:   O(n)

====================================================================
9Ô∏è‚É£ TRAVERSAL
====================================================================

------------------------------------------------------------
Range-based loop (recommended):
------------------------------------------------------------
for(auto &p : ump){
    cout << p.first << " " << p.second << endl;
}

------------------------------------------------------------
Iterator traversal:
------------------------------------------------------------
for(auto it = ump.begin(); it != ump.end(); ++it){
    cout << it->first << " " << it->second << endl;
}

‚ö†Ô∏è Order is RANDOM (do not rely on it)

====================================================================
üîü ITERATORS
====================================================================

‚Ä¢ unordered_map iterators are FORWARD iterators

------------------------------------------------------------
Valid:
------------------------------------------------------------
++it

------------------------------------------------------------
Invalid:
------------------------------------------------------------
--it
it + 1

====================================================================
1Ô∏è‚É£1Ô∏è‚É£ SIZE, EMPTY, CLEAR
====================================================================

ump.size();     // O(1)
ump.empty();   // O(1)
ump.clear();   // O(n)

====================================================================
1Ô∏è‚É£2Ô∏è‚É£ LOAD FACTOR & REHASHING (IMPORTANT)
====================================================================

------------------------------------------------------------
load_factor:
------------------------------------------------------------
load_factor = size / bucket_count

------------------------------------------------------------
Default max_load_factor:
------------------------------------------------------------
1.0

------------------------------------------------------------
If load_factor exceeds limit:
------------------------------------------------------------
‚Ä¢ Rehashing happens
‚Ä¢ All elements redistributed
‚Ä¢ Expensive operation

------------------------------------------------------------
Useful functions:
------------------------------------------------------------
ump.bucket_count();
ump.load_factor();
ump.max_load_factor(0.7);
ump.reserve(100000);   // CP GOLD

====================================================================
1Ô∏è‚É£3Ô∏è‚É£ STRING AS KEY (COMPLEXITY)
====================================================================

Let:
------------------------------------------------------------
L = length of string

------------------------------------------------------------
Hashing cost:
------------------------------------------------------------
O(L)

------------------------------------------------------------
Overall complexity:
------------------------------------------------------------
Average: O(L)
Worst:   O(n √ó L)

====================================================================
1Ô∏è‚É£4Ô∏è‚É£ CUSTOM KEY (pair / struct)
====================================================================

------------------------------------------------------------
Example: pair<int,int> as key
------------------------------------------------------------
struct PairHash {
    size_t operator()(const pair<int,int>& p) const {
        return hash<int>()(p.first) ^ hash<int>()(p.second);
    }
};

unordered_map<pair<int,int>, int, PairHash> ump;

====================================================================
1Ô∏è‚É£5Ô∏è‚É£ unordered_map vs map
====================================================================

map:
------------------------------------------------------------
‚Ä¢ Ordered
‚Ä¢ Red-Black Tree
‚Ä¢ O(log n)
‚Ä¢ Slower but stable

unordered_map:
------------------------------------------------------------
‚Ä¢ Unordered
‚Ä¢ Hash Table
‚Ä¢ O(1) average
‚Ä¢ Faster but risky worst-case

====================================================================
1Ô∏è‚É£6Ô∏è‚É£ WHEN TO USE unordered_map
====================================================================

‚úî Frequency counting
‚úî Fast lookup needed
‚úî Order doesn't matter
‚úî Large constraints

====================================================================
1Ô∏è‚É£7Ô∏è‚É£ WHEN NOT TO USE
====================================================================

‚ùå When sorted order is required
‚ùå When lower_bound / upper_bound needed
‚ùå When hacking possible (worst-case risk)

====================================================================
1Ô∏è‚É£8Ô∏è‚É£ COMMON MISTAKES
====================================================================

‚ùå Assuming order is preserved
‚ùå Forgetting reserve() ‚Üí TLE
‚ùå Using operator[] for checking existence
‚ùå Using complex keys without custom hash

====================================================================
1Ô∏è‚É£9Ô∏è‚É£ CP TIPS (IMPORTANT)
====================================================================

‚Ä¢ Always call reserve(n) for large input
‚Ä¢ Lower max_load_factor for speed
‚Ä¢ Use unordered_map<int,int> for freq
‚Ä¢ Avoid string keys when possible

====================================================================
2Ô∏è‚É£0Ô∏è‚É£ INTERVIEW ONE-LINER
====================================================================

std::unordered_map is a hash-table based associative container
that provides average O(1) insertion, deletion, and lookup
with no ordering of keys.

********************************************************************/
