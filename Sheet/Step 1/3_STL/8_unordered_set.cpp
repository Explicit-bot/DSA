/*
1Ô∏è‚É£ WHAT IS std::unordered_set?
====================================================================
std::unordered_set is an associative container that stores
UNIQUE elements using a HASH TABLE.

‚Ä¢ Elements are UNIQUE
‚Ä¢ NO sorting / NO fixed order
‚Ä¢ Very fast average operations
‚Ä¢ Uses HASHING internally

------------------------------------------------------------
Header:
------------------------------------------------------------
#include <unordered_set>

------------------------------------------------------------
Basic Syntax:
------------------------------------------------------------
unordered_set<DataType> ust;

Example:
------------------------------------------------------------
unordered_set<int> ust;
unordered_set<string> s;

====================================================================
2Ô∏è‚É£ INTERNAL IMPLEMENTATION
====================================================================
‚Ä¢ Data Structure: Hash Table
‚Ä¢ Uses hash(key) ‚Üí bucket
‚Ä¢ Buckets use chaining (or similar)

------------------------------------------------------------
Mental Model:
------------------------------------------------------------
value ‚Üí hash(value) ‚Üí bucket

====================================================================
3Ô∏è‚É£ KEY RULE (VERY IMPORTANT)
====================================================================
Element type MUST:
------------------------------------------------------------
‚Ä¢ Be HASHABLE
‚Ä¢ Have == operator defined

------------------------------------------------------------
Built-in hash available for:
------------------------------------------------------------
int
long long
char
string

------------------------------------------------------------
NOT directly supported:
------------------------------------------------------------
pair<int,int>     ‚ùå
vector<int>       ‚ùå
custom struct     ‚ùå

(unless custom hash is provided)

====================================================================
4Ô∏è‚É£ INSERTION
====================================================================
------------------------------------------------------------
insert()
------------------------------------------------------------
ust.insert(10);
ust.insert(5);
ust.insert(10);   // ignored (duplicate)

------------------------------------------------------------
emplace()
------------------------------------------------------------
ust.emplace(20);

------------------------------------------------------------
Time Complexity:
------------------------------------------------------------
Average: O(1)
Worst:   O(n)

====================================================================
5Ô∏è‚É£ ACCESSING ELEMENTS
====================================================================
------------------------------------------------------------
‚ùå No index access
------------------------------------------------------------
ust[0];   // INVALID

------------------------------------------------------------
Access using iterator:
------------------------------------------------------------
auto it = ust.begin();
cout << *it;

====================================================================
6Ô∏è‚É£ find()
====================================================================

------------------------------------------------------------
Syntax:
------------------------------------------------------------
auto it = ust.find(x);

------------------------------------------------------------
Returns:
------------------------------------------------------------
‚Ä¢ Iterator if found
‚Ä¢ ust.end() if not found

------------------------------------------------------------
Time:
------------------------------------------------------------
Average: O(1)
Worst:   O(n)

====================================================================
7Ô∏è‚É£ count()
====================================================================
------------------------------------------------------------
Syntax:
------------------------------------------------------------
ust.count(x);

------------------------------------------------------------
Returns:
------------------------------------------------------------
1 ‚Üí exists
0 ‚Üí does not exist

------------------------------------------------------------
Time:
------------------------------------------------------------
Average: O(1)
Worst:   O(n)

====================================================================
8Ô∏è‚É£ ERASE (IMPORTANT)
====================================================================
------------------------------------------------------------
Erase by value:
------------------------------------------------------------
ust.erase(x);

------------------------------------------------------------
Erase by iterator:
------------------------------------------------------------
auto it = ust.find(x);
ust.erase(it);

------------------------------------------------------------
Erase range:
------------------------------------------------------------
ust.erase(ust.begin(), ust.end());

------------------------------------------------------------
Time:
------------------------------------------------------------
Average: O(1)
Worst:   O(n)

------------------------------------------------------------
Safe erase while iterating:
------------------------------------------------------------
for(auto it = ust.begin(); it != ust.end(); ){
    if(*it % 2 == 0)
        it = ust.erase(it);
    else
        ++it;
}

====================================================================
9Ô∏è‚É£ TRAVERSAL
====================================================================
------------------------------------------------------------
Range-based loop:
------------------------------------------------------------
for(auto x : ust){
    cout << x << " ";
}

------------------------------------------------------------
Iterator loop:
------------------------------------------------------------
for(auto it = ust.begin(); it != ust.end(); ++it){
    cout << *it << " ";
}

‚ö†Ô∏è Order is RANDOM ‚Äî never rely on it

====================================================================
üîü ITERATORS
====================================================================

‚Ä¢ unordered_set iterators are FORWARD iterators
------------------------------------------------------------
Valid:
------------------------------------------------------------
++it

------------------------------------------------------------
Invalid:
------------------------------------------------------------
--it
it + 1

====================================================================
1Ô∏è‚É£1Ô∏è‚É£ SIZE, EMPTY, CLEAR
====================================================================

ust.size();     // O(1)
ust.empty();   // O(1)
ust.clear();   // O(n)

====================================================================
1Ô∏è‚É£2Ô∏è‚É£ LOAD FACTOR & REHASHING (üî• IMPORTANT)
====================================================================

------------------------------------------------------------
load_factor:
------------------------------------------------------------
load_factor = size / bucket_count

------------------------------------------------------------
Default max_load_factor:
------------------------------------------------------------
1.0

------------------------------------------------------------
When load factor exceeds limit:
------------------------------------------------------------
‚Ä¢ Rehashing occurs
‚Ä¢ All elements redistributed
‚Ä¢ Expensive operation

------------------------------------------------------------
Useful functions:
------------------------------------------------------------
ust.bucket_count();
ust.load_factor();
ust.max_load_factor(0.7);
ust.reserve(100000);   // CP GOLD

====================================================================
1Ô∏è‚É£3Ô∏è‚É£ STRING AS ELEMENT (COMPLEXITY)
====================================================================

Let:
------------------------------------------------------------
L = length of string

------------------------------------------------------------
Hashing cost:
------------------------------------------------------------
O(L)

------------------------------------------------------------
Overall complexity:
------------------------------------------------------------
Average: O(L)
Worst:   O(n √ó L)

====================================================================
1Ô∏è‚É£4Ô∏è‚É£ CUSTOM HASH (ADVANCED)
====================================================================

------------------------------------------------------------
Example: pair<int,int> as element
------------------------------------------------------------
struct PairHash {
    size_t operator()(const pair<int,int>& p) const {
        return hash<int>()(p.first) ^ hash<int>()(p.second);
    }
};

unordered_set<pair<int,int>, PairHash> ust;

====================================================================
1Ô∏è‚É£5Ô∏è‚É£ unordered_set vs set
====================================================================

set:
------------------------------------------------------------
‚Ä¢ Ordered
‚Ä¢ Red-Black Tree
‚Ä¢ O(log n)
‚Ä¢ lower_bound supported

unordered_set:
------------------------------------------------------------
‚Ä¢ Unordered
‚Ä¢ Hash Table
‚Ä¢ O(1) average
‚Ä¢ Faster lookups

====================================================================
1Ô∏è‚É£6Ô∏è‚É£ WHEN TO USE unordered_set
====================================================================
‚úî Fast presence check
‚úî Duplicate removal
‚úî Large input size
‚úî Order does not matter

====================================================================
1Ô∏è‚É£7Ô∏è‚É£ WHEN NOT TO USE
====================================================================
‚ùå Need sorted data
‚ùå Need lower_bound / upper_bound
‚ùå Need deterministic iteration order

====================================================================
1Ô∏è‚É£8Ô∏è‚É£ COMMON MISTAKES
====================================================================
‚ùå Assuming order is preserved
‚ùå Forgetting reserve() ‚Üí TLE
‚ùå Using complex keys without hash
‚ùå Ignoring worst-case behavior
*/
