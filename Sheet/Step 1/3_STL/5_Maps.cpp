/*
====================================================================
1Ô∏è‚É£ WHAT IS std::map?
====================================================================
std::map is an ordered associative container that stores elements
in the form of (KEY, VALUE) pairs.

‚Ä¢ Keys are UNIQUE
‚Ä¢ Elements are STORED IN SORTED ORDER (by key)
‚Ä¢ Implemented using RED-BLACK TREE (self-balancing BST)
‚Ä¢ No random access (not index-based)
‚ö†Ô∏è There is NO direct way to say: give me key at index i
------------------------------------------------------------
Header:
------------------------------------------------------------
#include <map>

------------------------------------------------------------
Basic Syntax:
------------------------------------------------------------
map<KeyType, ValueType> mp;

Example:
------------------------------------------------------------
map<int, int> mp;
map<string, int> freq;

====================================================================
2Ô∏è‚É£ INTERNAL IMPLEMENTATION
====================================================================
‚Ä¢ Data Structure: Red-Black Tree
‚Ä¢ Height of tree: O(log n)
‚Ä¢ All major operations depend on tree height

Why important?
------------------------------------------------------------
Because EVERY operation involves:
‚Ä¢ Tree traversal
‚Ä¢ Key comparison

====================================================================
3Ô∏è‚É£ KEY RULE (VERY IMPORTANT)
====================================================================
KEY:
------------------------------------------------------------
‚Ä¢ Must be UNIQUE
‚Ä¢ Must be COMPARABLE using operator <

VALUE:
------------------------------------------------------------
‚Ä¢ Can be ANY datatype
‚Ä¢ No restrictions

====================================================================
4Ô∏è‚É£ POSSIBLE DATA TYPES
====================================================================
------------------------------------------------------------
Common KEY types:
------------------------------------------------------------
int
long long
char
string
pair<int,int>
vector<int>        // allowed but slow
custom struct      // only if < is defined

====================================================================
5Ô∏è‚É£ INSERTION
====================================================================
------------------------------------------------------------
Method 1: operator[]
------------------------------------------------------------
mp[1] = 10;

‚Ä¢ Inserts if key not present
‚Ä¢ Updates if key exists

Time: O(log n)

------------------------------------------------------------
Method 2: insert()
------------------------------------------------------------
mp.insert({2, 20});

------------------------------------------------------------
Method 3: emplace()
------------------------------------------------------------
mp.emplace(3, 30);

‚úî Slightly faster (no temporary object)

====================================================================
6Ô∏è‚É£ ACCESSING ELEMENTS
====================================================================
------------------------------------------------------------
Using operator[]
------------------------------------------------------------
cout << mp[1];

‚ö†Ô∏è If key doesn't exist:
‚Ä¢ New key is created
‚Ä¢ Default value is assigned

------------------------------------------------------------
Safe access using find():
------------------------------------------------------------
if(mp.find(1) != mp.end()){
    cout << mp[1];
}

====================================================================
7Ô∏è‚É£ find() FUNCTION
====================================================================
------------------------------------------------------------
Syntax:
------------------------------------------------------------
auto it = mp.find(key);

‚Ä¢ Returns iterator if found
‚Ä¢ Returns mp.end() if not found

Time:
------------------------------------------------------------
O(log n)

====================================================================
8Ô∏è‚É£ count()
====================================================================

------------------------------------------------------------
Syntax:
------------------------------------------------------------
mp.count(key);

‚Ä¢ Returns 1 if key exists
‚Ä¢ Returns 0 otherwise

Time:
------------------------------------------------------------
O(log n)

====================================================================
9Ô∏è‚É£ ERASE (VERY IMPORTANT)
====================================================================
------------------------------------------------------------
Erase by key:
------------------------------------------------------------
mp.erase(key);

Time:
------------------------------------------------------------
O(log n)

------------------------------------------------------------
Erase by iterator:
------------------------------------------------------------
auto it = mp.find(key);
mp.erase(it);

Time:
------------------------------------------------------------
O(1) amortized (after find)

------------------------------------------------------------
Erase range:
------------------------------------------------------------
mp.erase(mp.begin(), mp.end());

Time:
------------------------------------------------------------
O(n)

------------------------------------------------------------
Safe erase while iterating:
------------------------------------------------------------
for(auto it = mp.begin(); it != mp.end(); ){
    if(it->first % 2 == 0)
        it = mp.erase(it);
    else
        ++it;
}

====================================================================
üîü TRAVERSAL
====================================================================
------------------------------------------------------------
Iterator traversal:
------------------------------------------------------------
for(auto it = mp.begin(); it != mp.end(); ++it){
    cout << it->first << " " << it->second << endl;
}

------------------------------------------------------------
Range-based loop (recommended):
------------------------------------------------------------
for(auto &p : mp){
    cout << p.first << " " << p.second << endl;
}

------------------------------------------------------------
Reverse traversal:
------------------------------------------------------------
for(auto it = mp.rbegin(); it != mp.rend(); ++it){
    cout << it->first << endl;
}

====================================================================
1Ô∏è‚É£1Ô∏è‚É£ ITERATORS & MOVEMENT
====================================================================

‚Ä¢ map iterators are BIDIRECTIONAL

------------------------------------------------------------
Valid:
------------------------------------------------------------
++it
--it

------------------------------------------------------------
Invalid:
------------------------------------------------------------
it + 1   // ‚ùå NOT allowed

Reason:
------------------------------------------------------------
map is NOT random-access

====================================================================
1Ô∏è‚É£2Ô∏è‚É£ SIZE, EMPTY, CLEAR
====================================================================
------------------------------------------------------------
size():
------------------------------------------------------------
mp.size();     // O(1)

------------------------------------------------------------
empty():
------------------------------------------------------------
mp.empty();    // O(1)

------------------------------------------------------------
clear():
------------------------------------------------------------
mp.clear();    // O(n)

====================================================================
1Ô∏è‚É£3Ô∏è‚É£ TIME COMPLEXITY SUMMARY
====================================================================

Operation                Complexity
------------------------------------------------------------
insert                   O(log n)
erase(key)               O(log n)
erase(iterator)          O(1)
find                     O(log n)
count                    O(log n)
mp[key]                  O(log n)
traversal                O(n)
clear                    O(n)

====================================================================
1Ô∏è‚É£4Ô∏è‚É£ STRING AS KEY (SPECIAL CASE)
====================================================================
Let:
------------------------------------------------------------
n = number of elements
L = length of string key

------------------------------------------------------------
Why extra cost?
------------------------------------------------------------
‚Ä¢ Tree comparison = O(log n)
‚Ä¢ String comparison = O(L)

------------------------------------------------------------
Final complexity:
------------------------------------------------------------
insert / find / erase:
O(log n √ó L)

====================================================================
1Ô∏è‚É£5Ô∏è‚É£ WHEN TO USE map
====================================================================
‚úî Need sorted order
‚úî Need lower_bound / upper_bound
‚úî Lexicographical traversal
‚úî Deterministic performance

====================================================================
1Ô∏è‚É£6Ô∏è‚É£ COMMON MISTAKES
====================================================================

‚ùå Expecting O(1) access
‚ùå Using it+1
‚ùå Using mp[key] just to check existence
‚ùå Using map<string> for huge data
‚ùå Modifying map incorrectly while iterating

====================================================================
1Ô∏è‚É£7Ô∏è‚É£ CP TIPS
====================================================================
‚Ä¢ Prefer unordered_map for frequency counting
‚Ä¢ Use map when ordering matters
‚Ä¢ Avoid string keys if possible
‚Ä¢ Use pair<int,int> instead of string when you can
*/
